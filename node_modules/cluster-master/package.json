{
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "name": "cluster-master",
  "description": "A helper script for managing a cluster of node worker servers",
  "version": "0.2.0",
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/cluster-master.git"
  },
  "main": "cluster-master.js",
  "engines": {
    "node": ">=0.7.7"
  },
  "license": "BSD",
  "readme": "# cluster-master\n\nA module for taking advantage of the built-in `cluster` module in node\nv0.8 and above.\n\nYour main `server.js` file uses this module to fire up a cluster of\nworkers.  Those workers then do the actual server stuff (using socket.io,\nexpress, tako, raw node, whatever; any TCP/TLS/HTTP/HTTPS server would\nwork.)\n\nThis module provides some basic functionality to keep a server running.\nAs the name implies, it should only be run in the master module, not in\nany cluster workers.\n\n```javascript\nvar clusterMaster = require(\"cluster-master\")\n\n// most basic usage: just specify the worker\n// Spins up as many workers as you have CPUs\n//\n// Note that this is VERY WRONG for a lot of multi-tenanted\n// VPS environments where you may have 32 CPUs but only a\n// 256MB RSS cap or something.\nclusterMaster(\"worker.js\")\n\n// more advanced usage.  Specify configs.\n// in real life, you can only actually call clusterMaster() once.\nclusterMaster({ exec: \"worker.js\" // script to run\n              , size: 5 // number of workers\n              , env: { SOME: \"environment_vars\" }\n              , args: [ \"--deep\", \"doop\" ]\n              , silent: true\n              , signals: false\n              , onMessage: function (msg) {\n                  console.error(\"Message from %s %j\"\n                               , this.uniqueID\n                               , msg)\n                }\n              })\n\n// methods\nclusterMaster.resize(10)\n\n// graceful rolling restart\nclusterMaster.restart()\n\n// graceful shutdown\nclusterMaster.quit()\n\n// not so graceful shutdown\nclusterMaster.quitHard()\n```\n\n## Methods\n\n### clusterMaster.resize(n)\n\nSet the cluster size to `n`.  This will disconnect extra nodes and/or\nspin up new nodes, as needed.  Done by default on restarts.\n\n### clusterMaster.restart(cb)\n\nOne by one, shut down nodes and spin up new ones.  Callback is called\nwhen finished.\n\n### clusterMaster.quit()\n\nGracefully shut down the worker nodes and then process.exit(0).\n\n### clusterMaster.quitHard()\n\nForcibly shut down the worker nodes and then process.exit(1).\n\n## Configs\n\nThe `exec`, `env`, `argv`, and `silent` configs are passed to the\n`cluster.fork()` call directly, and have the same meaning.\n\n* `exec` - The worker script to run\n* `env` - Envs to provide to workers\n* `argv` - Additional args to pass to workers.\n* `silent` - Boolean, default=false.  Do not share stdout/stderr\n* `size` - Starting cluster size.  Default = CPU count\n* `signals` - Boolean, default=true.  Set up listeners to:\n  * `SIGHUP` - restart\n  * `SIGINT` - quit\n* `onMessage` - Method that gets called when workers send a message to\n  the parent.  Called in the context of the worker, so you can reply by\n  looking at `this`.\n* `repl` - where to have REPL listen, defaults to `env.CLUSTER_MASTER_REPL` || 'cluster-master-socket'\n  * if `repl` is null or false - REPL is disabled and will not be started\n  * if `repl` is string path - REPL will listen on unix domain socket to this path\n  * if `repl` is an integer port - REPL will listen on TCP 0.0.0.0:port\n  * if `repl` is an object with `address` and `port`, then REPL will listen on TCP address:PORT\n\nExamples of configuring `repl`\n\n```javascript\nvar config = { repl: false }                       // disable REPL\nvar config = { repl: '/tmp/cluster-master-sock' }  // unix domain socket\nvar config = { repl: 3001 }                        // tcp socket 0.0.0.0:3001\nvar config = { repl: { address: '127.0.0.1', port: 3002 }}  // tcp 127.0.0.1:3002\n```\n\nNote: be careful when using TCP for your REPL since anyone on the\nnetwork can connect to your REPL (no security). So either disable\nthe REPL or use a unix domain socket which requires local access\n(or ssh access) to the server.\n\n## REPL\n\nCluster-master provides a REPL into the master process so you can inspect\nthe state of your cluster. By default the REPL is accessible by a socket\nwritten to the root of the directory, but you can override it with the\n`CLUSTER_MASTER_REPL` environment variable. You can access the REPL with\nnc or [socat](http://www.dest-unreach.org/socat/) like so:\n\n\n```bash\nnc -U ./cluster-master-socket\n\n# OR\n\nsocat ./cluster-master-socket stdin\n```\n\nThe REPL provides you with access to these objects or functions:\n\n* `help`        - display these commands\n* `repl`        - access the REPL\n* `resize(n)`   - resize the cluster to `n` workers\n* `restart(cb)` - gracefully restart workers, cb is optional\n* `stop()`      - gracefully stop workers and master\n* `kill()`      - forcefully kill workers and master\n* `cluster`     - node.js cluster module\n* `size`        - current cluster size\n* `connections` - number of REPL connections to master\n* `workers`     - current workers\n* `select(fld)` - map of id to `field` (from workers)\n* `pids`        - map of id to pids\n* `ages`        - map of id to worker ages\n* `states`      - map of id to worker states\n* `debug(a1)`   - output `a1` to stdout and all REPLs\n* `sock`        - this REPL socket'\n* `.exit`       - close this connection to the REPL\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/isaacs/cluster-master/issues"
  },
  "homepage": "https://github.com/isaacs/cluster-master",
  "_id": "cluster-master@0.2.0",
  "dist": {
    "shasum": "e6379897179ebce79ab783ccd7ee26dec55b3d46"
  },
  "_from": "cluster-master@*",
  "_resolved": "http://registry.npmjs.org/cluster-master/-/cluster-master-0.2.0.tgz"
}
